# SolarKeywordsIntellegencyTree
搜索智能关键字提示

![](https://i.imgur.com/yZGNjIW.png)

![](https://i.imgur.com/Pgyz4us.png)

<pre>
Solr集群
</pre>

<pre>
Solr VS Elasticsearch

      1：Solr利用Zookeeper进行分布式管理，而ElasticSearch自带分布式协调管理功能。
      2：Solr支持更多格式的数据，而ElasticSearch仅支持json文件格式。
      3：Solr官方提供的功能更多，而Elasticsearch本身更注重于核心功能，高级功能由第三方
         插件提供。
      5：Solr在传统的搜索应用中表现好于Elasticsearch，但是在处理实时搜索应用时效率明显
         低于Elasticsearch。
      6：Solr是传统搜索应用的有力解决方案，但Elasticsearch更适合用于新兴的实时搜索应用。

      7：当单纯的对已有数据进行搜索时，Solr更快。
      8）当实时建立索引时，Solr会产生IO阻塞，查询性能较差，ES具有明显的优势。
      9）随着数据量的增加，Solr的搜索效率变得更低，而ElasticSearch却没有明显变化。
      10）Solr的架构不适合实时搜索的应用。

      11）二者安装都很简单；

      12）Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能;

      13）Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式；

      15）Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供；

      16）Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch。

      17）Solr 是传统搜索应用的有力解决方案，但 Elasticsearch 更适用于新兴的实时搜索应用。
</pre>

<pre>
Elasticsearch

      Elasticsearch是一个实时的分布式搜索和分析引擎，它可以帮助你用前所未有的速度去处理
      大规模数据。它可用于全文搜索，结构化索引以及分析。

      Elasticsearch是一个简历在全文搜索引擎Apache Lucene基础上的搜索引擎，可以说Lucene
      是当今最先进，最高效的全功能开源搜索框架。

      Elasticsearch使用Lucene作为内部引擎，但是在使用它做全文搜索时，只需要使用统一API
      即可。
          1）分布式实时文件存储，并将每个字段都编入索引，使其可以被检索。
          2）实时分析的分布式搜索引擎。
          3）可以扩展到上百台服务器，处理PB级别的结构化或非结构化数据。

          使用案例：
                  1：维基百科使用Elasticsearch来进行全文搜索并高亮显示关键词。
                  2：卫报全文搜索

      Elasticsearch的优缺点：
          优点：
              1）Elasticsearch是分布式的，不需要其他组件，分发是实时的，被叫做push replication.
              2) Elasticsearch完全支持Apache Lucene的接近实时的搜索。
              3）处理多租户。
              5）Es使用Gateway的概念，使得完全备份更加简单。
              6）各节点组成对等的网络结构，某些节点出现故障会自动分配其他节点代替其进行工作。
</pre>

<pre>
Solr

      Solr是Apache Lucene项目的开源企业搜索平台。其主要功能包括：
            1）全文检索
            2）命中标示
            3）分面搜索
            5）动态聚类
            6）数据库集成
            7）富文本的处理

      Solr是用Java写的，运行在Servlet容器的一个独立的全文搜索服务器，Solr采用了Lucene Java搜索库为核心
      的全文索引和搜索。并具有类似Rest的HTTP/XML和json的API，
</pre>

<pre>
Solr/Es的不足

      1、Solr/ES分词的不足之处

        对于邮箱、手机号、车牌号码、网址、IP地址、程序类名、含有字母与数字的组合之类的数据会匹配不完整，
        导致数据查不全，因分词导致漏查以及缺失数据，对于模糊检索有精确匹配要求的场景下，业务存在较
        大的风险。如何玩转Solr/ES，能够自定义拓展任意的分词类型，如词库分词，语义分词，拼音分词等

      2、Solr/ES在模糊匹配中的实际问题

        Solr/ES的模糊匹配是基于Lucene的分词来实现，但并不考虑单词的匹配顺序，也不保证匹配词语的连续性，
        中间可以穿插其他单词。为什么不能支持类似SQL中的like匹配，既考虑到了单词之间的匹配顺序，也保证了
        匹配词语的连续性，也可以通过*进行模糊查询，并能实现较高的like性能

      3、Solr/ES的用户接口为何不能丰富些?

        除了Java API，能不能支持标准SQL的方式，支持JDBC/ODBC接入，能否与大数据生态中其他标准组件无缝
        对接如Hive，Spark，Kafka等，也可与常见的报表工具、SQL可视化工具集成。

      4、对函数的支持

        Solr/ES只支持简单的检索过滤，sum，max，min，avg等统计函数，单列groupby。是否能支持更多的函数，
        支持复杂的SQL，可以嵌套，多表关联，甚至自定义udf，udaf，udtf

      5、数据导出如何实现？

        Solr/ES中的数据如若想导出到其他系统是比较难，海量原始数据的导出基本是不可行的，更不要说将原始
        数据经过各种复杂计算清洗后的导出了。比如：支持原始数据的任意维度导出，可以全表，也可以通过过滤
        筛选局部导出，支持数据经过各种组合计算过滤后的导出。

      6、如何解决高性能排序？

        按照时间逆序排序是很系统的硬指标。Solr/ES是采用Lucene的Sort接口实现，本质是借助DocValues的暴力
        扫描，如果数据量很大的情况下，排序过程会耗费大量的内存与IO资源，排序性能很低。

      7、冷热索引处理机制问题

        Solr/ES中默认是打开全部的索引，每个索引都会独占一些资源，如内存、文件描述符等。但是一台机器的内存
        与文件描述符始终是有限的，从而也限制了Solrs/ES能够装载的数据规模，在机器资源有限的情况下，制约了
        数据规模。

      8、稳定性难题

        1．笔者在实际环境中，在数据规模超过千万或过亿后，生产系统实时导入经常会出现OOM，以及CPU负载太
           高的问题，过亿数据事实上无法实时导入数据，一般过百亿的系统均采用离线创建索引的方式，即数据
           时效性延迟一天。

        2．Solr/ES中数据规模一旦过百亿，就会频繁的出现OOM，节点调片的情况。一旦调片后无法自动恢复服务，
           需要运维人员去重启相关服务。系统缺少过载保护，经常是一个人员做了一个复杂的查询，导致集群整体
           宕机，系统崩溃。这导致当数据量过亿后，Solr/ES在数据量比较大的情况下，实时索引几乎是不可能的，
           频繁的ord关系映射，会让整个系统不可用。

      9、数据存储与恢复

           Solr/ES索引存储在本地硬盘，数据恢复比较难：

           1．磁盘读写没有很好的控速机制，导入数据没有良好的流量控制机制，无法控制流量，而生产系统，磁盘
             控速与流量控速是必须的，不能因为业务高峰对系统造成较大的冲击，导致磁盘都hang住或挂掉。

           2．本地硬盘局部坏点，对于Solr/ES来说哪怕是仅仅一个byte数据的读异常，就会造成索引指针的错乱，
              导致检索结果数据丢失，甚至整个索引废掉，但是Solr与ES如何及时的发现并修正这些错误呢？

           3．数据存储在本地磁盘，一旦本地将近20T的存储盘损坏，需要从副本恢复后才能继续服务，恢复时间太长。

      10、数据迁移之难

         Solr/ES上如何实现跨机房数据迁移，需要运维人员细心的进行索引1对1复制，搬迁方案往往要数星期，且
         非常容易出错。而且迁移过程中为了保证数据的一致性，需要中断服务或者中断数据的实时导入，让数据静态
         化落地后不允许在变化后，才能进行迁移。
</pre>